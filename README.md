# iot_visualisation

Проблема
Энергосистемы развитых стран наращивают тренд обеспечения питания засчет энергии солнца. Электричество призвано заместить другие более вредные типы энергообеспечения, но стабильность солнечных батарей ставится под вопрос. В стране немало энергодефицитных территорий, где бывает необходимо выставить системы хранения информации, геолокации, связи и другие. Энергообеспечение таких систем требует бесперебойного питания и на ряду с солнечными батареями стоит задача разработать датчики отслеживания состояния окружающей среды. Такую проблему способна решить область интернета вещей. В данной курсовой работе реализуется датчик, который способен обрабатывать изображение с камеры, находить на нем солнце и анализировать поведение облаков. В случае прогнозирования перекрытия облаками солнца, датчик будет отдавать сигнал на включение альтернативных систем энергообеспечения.
В качестве языка программирования для курсового проекта был выбран Python, библиотека OpenCV.
В этой задаче можно выделить три основные составляющие:
1.	Определение солнца на изображении
2.	Определение облаков на изображении
3.	Анализ поведения и как следствие – принятие решения

 
Реализация
1.	Анализ солнца на изображении
Изображение переводится из цветовой модели RGB в модель HSV, так как RGB содержит в себе 3 слоя, которые накладываются друг на друга, поэтому обработку изображения целесообразнее выполнять в HSV. 
img_hsvSun = cv2.cvtColor(img_rgbSun, cv2.COLOR_BGR2HSV)
img_rgbSun = cv2.GaussianBlur(src=img_rgb, ksize=(7, 7), sigmaX=0)

Затем выполняется определение бинарной маски, методом cv2.inRange задается диапазон для конвертирования и получается следующий вид: 
highLevelSun = np.array([255, 255, 255])
lowerLevelSun = np.array([15, 15, 15])
sunMask = cv2.inRange(img_hsvSun, lowerLevelSun, highLevelSun)

 
Рис 1. Результат обработки изображения методом inRange

	На маске получается характерная для солнца фигура – круг. Для определения круга на изображении библиотека предусматривает метод cv2.HoughCircles. Результат определения представлен на рисунке ниже:
circles = cv2.HoughCircles(sunMask, cv2.HOUGH_GRADIENT, 1, 2000, param1=30, param2=24, minRadius=10,maxRadius=900)
if circles is not None:
    circles = np.round(circles[0, :]).astype("int")
    print("Sun locate:  " + str(circles))
   cv2.putText(img_rgb, 'Sun', (circles[0, 0] - 65, circles[0, 1] - 170), cv2.FONT_HERSHEY_DUPLEX, 2, (36, 255, 12), thickness=3)  # текст
    for (x, y, r) in circles:
        cv2.circle(img_rgb, (x, y), r+20, (36, 255, 12), 5)

 
Рис 2. Результат определения круга методом HoughCircles

Если учитывать, что солнце перемещается не так быстро, как облака, то можно зафиксировать местоположение условно на час, потом определение выполнять повторно. 

 
2.	Анализ облаков на изображении
Проблемами определения облаков выступали цвет и лучистость солнца, поэтому реализация выполнена на основании нахождения разницы между двумя изображениями, настоящим и предыдущем. Другими словами, определение движущихся объектов на изображении. 
Пример результата определения разницы между двумя изображениями представлен ниже. Создается маска, после чего движущиеся объекты преобразовываются в массив контуров. 
 
Рис 2. Пример определения движущихся объектов

В начале изображение переводится из цветовой модели RGB в модель GRAY и немного размывается, потому что обрабатывать 3 слоя не целесообразно. Для этого подхода достаточно черно белой модели. 
cap = cv2.VideoCapture("videos/video1.mov")
previous_frame = None

while True:
    success, img_rgb = cap.read()


    # 1. Prepare image; grayscale and blur
prepared_frame = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
prepared_frame = cv2.GaussianBlur(src=prepared_frame, ksize=(5, 5), sigmaX=9)


Затем определяем движение (изменение по сравнению с предыдущим кадром). 	В этой части происходит фактическое обнаружение движения. Сравнивается предыдущий кадр с текущим. В приведенном ниже коде устанавливается предыдущий кадр, если его нет. Затем вычисляется разница по absdiff методу. После этого обновляется наш предыдущий кадр. Далее немного разбавляется изображение. Расширение заполняет отверстия и соединяет области; он делает небольшие различия немного четче, увеличивая размер и яркость.

# 2. Calculate the difference
if (previous_frame is None):
    # First frame; there is no previous one yet
    previous_frame = prepared_frame
    continue

# 3. Set previous frame and continue if there is None
if (previous_frame is None):
    # First frame; there is no previous one yet
    previous_frame = prepared_frame
    continue

# calculate difference and update previous frame
diff_frame = cv2.absdiff(src1=previous_frame, src2=prepared_frame)
previous_frame = prepared_frame

# 4. Dilute the image a bit to make differences more seeable; more suitable for contour detection
kernel = np.ones((5, 5))
diff_frame = cv2.dilate(diff_frame, kernel, 1)

# 5. Only take different areas that are different enough (>20 / 255)
thresh_frame = cv2.threshold(src=diff_frame, thresh=5, maxval=255, type=cv2.THRESH_BINARY)[1]

Затем используется cv2.threshold, функция для преобразования каждого пикселя либо в 0 (белый), либо в 1 (черный). Порог для этого 20; если разница в оттенках между текущим и предыдущим кадром больше 20, этот пиксель становится белым, иначе — черным. 

После чего необходимо найти область, которая изменилась с момента последнего кадра, а не каждый пиксель. Для этого сначала нужно найти площадь. Функция cv.findContours извлекает контуры или внешние границы каждого белого пятна. В коде ниже находим и рисуем все контуры. 
# 6. Find and optionally draw contours
contours, _ = cv2.findContours(image=thresh_frame, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE)

# Comment below to stop drawing contours
cv2.drawContours(image=img_rgb, contours=contours, contourIdx=-1, color=(255, 0, 0), thickness=2,lineType=cv2.LINE_AA)


 
3.	Анализ поведения, принятие решения     
Для принятия решения необходимо определить критическую область солнца и в случае перекрытия этой области контурами облаков отдавать сигнал, допустим на включение дизель генератора. Для определения такой области берется маска с кругом на месте солнца и накладывается на систему определения движения облаков. То есть теперь движение облаков будет детектироваться только в районе солнца и записываться в массив, состоящий из контуров.
# Detect zone
prepared_frameMask = np.zeros(prepared_frame.shape[:2], dtype='uint8')
circle = cv2.circle(prepared_frameMask.copy(), (circles[0][0], circles[0][1]), circles[0][2] + 100, 255, -1)
prepared_frame = cv2.bitwise_and(prepared_frame, prepared_frame, mask=circle)

Теперь, когда есть массив контуров, следует сделать своего рода «Индекс подвижности». При превышении  порогового значения этого индекса будет выдаваться команда. То есть, определяется количество контуров в массиве и если контуров больше 10 то система добавляет 10 баллов к индексу, в если движения нет, то отнимает 1 балл. 
if len(contours) > 10 and detectIndex < 100:
    # print("contours:  " + str(len(contours)))
    detectIndex += 10
    # print("+detectIndex:  " + str(detectIndex))
elif detectIndex > 0:
    detectIndex -= 1
    # print("-detectIndex:  " + str(detectIndex))

При достижении 60 баллов, выводится команда «Включить», а при уменьшении индекса меньше 50 выводится команда «Выключить». Также предусмотрен блок индикатор, чтобы не спамить командами включения и выключения.
if detectIndex > 60 and locker == 0:
    print("Команда:  ВКЛЮЧИТЬ   (detectIndex:" + str(detectIndex) + ")")
    locker = 1
elif detectIndex < 50 and locker == 1:
    print("Команда:  ВЫКЛЮЧИТЬ   (detectIndex:" + str(detectIndex) + ")")
    locker = 0

Вывод
В качестве результата получен готовый алгоритм для датчика отслеживания состояния окружающей среды.
Алгоритм предусматривает:
•	Определение солнца на изображении
•	Определение облаков на изображении
•	Анализ поведения и как следствие – принятие решения
Для запуска нужна камера и сервер для обработки изображения. Алгоритм не предусматривает запуск во время закрытого облаками солнца. Местоположение солнца определяется на старте и имеет актуальность около часа, после чего следует обновлять местоположение. 
![image](https://user-images.githubusercontent.com/99203305/171029103-a2805c33-328a-49dd-ae08-02875fe8ee65.png)
